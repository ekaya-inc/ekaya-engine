# FIX: Persist Nonce Store to Database

**Status:** TODO (not required for launch)
**Priority:** Low
**Area:** `pkg/services/nonce_store.go`, activation/callback flow

## Problem

The `NonceStore` used for activation callback validation is in-memory only. This causes two issues:

1. **Multi-instance incompatibility:** If multiple ekaya-engine instances run behind a load balancer, a nonce generated by instance A won't be found by instance B when the callback arrives. The activation callback will fail with "invalid or expired callback nonce".

2. **Nonce leak on cancel:** When a user clicks Activate, gets redirected to Central, then cancels, the frontend returns early without calling the backend callback endpoint (`AIDataLiaisonPage.tsx:133`). The nonce is never consumed via `Validate()` and remains in the map forever (until server restart). Each activate→cancel cycle leaks one entry.

## Current Implementation

**Nonce store:** `pkg/services/nonce_store.go`
- In-memory `map[string]nonceEntry` protected by `sync.Mutex`
- `Generate()` creates a 32-byte random hex nonce tied to `(action, projectID, appID)`
- `Validate()` checks and deletes (single-use)
- No TTL, no cleanup, no max size

**Nonce generation:** `pkg/services/installed_app.go` in `buildCallbackURL()`
- Called during `Activate()`, `Uninstall()`, etc.
- Nonce is embedded in the callback URL sent to Central

**Nonce validation:** `pkg/services/installed_app.go` in `CompleteCallback()`
- Called when Central redirects back with success
- Validates nonce matches `(action, projectID, appID)` tuple

**Cancel path:** `ui/src/pages/AIDataLiaisonPage.tsx:122-164`
- On `callback_status === 'cancelled'`, frontend returns early — no backend call, nonce never consumed

## Solution

### 1. Create `engine_nonces` table

```sql
CREATE TABLE engine_nonces (
    nonce       TEXT PRIMARY KEY,
    action      TEXT NOT NULL,
    project_id  UUID NOT NULL,
    app_id      TEXT NOT NULL,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
    expires_at  TIMESTAMPTZ NOT NULL
);

CREATE INDEX idx_engine_nonces_expires_at ON engine_nonces (expires_at);
```

No RLS needed — nonces are validated by their cryptographic value, not by tenant context.

### 2. Create `NonceRepository`

In `pkg/repositories/`, create a repository with:
- `Create(ctx, nonce, action, projectID, appID, ttl)` — INSERT with `expires_at = now() + ttl`
- `ValidateAndDelete(ctx, nonce, action, projectID, appID)` — SELECT + DELETE in one transaction (only if not expired)
- `DeleteExpired(ctx)` — DELETE WHERE `expires_at < now()` (cleanup)

### 3. Replace in-memory NonceStore

Update `NonceStore` interface implementation to use the repository instead of the in-memory map. The interface (`Generate`, `Validate`) stays the same — only the backing store changes. The `NonceStore` will need a `context.Context` parameter added to both methods since it now does DB calls.

**TTL:** Use 15 minutes. Activation redirects to Central and back should complete well within that window.

### 4. Add cleanup to retention scheduler

The `RetentionService` (`pkg/services/retention_service.go`) already runs a background scheduler (`RunScheduler`) that prunes old data on a ticker. Add nonce cleanup to this existing loop rather than creating a separate goroutine.

- Inject `NonceRepository` into `retentionService`
- In `pruneAllProjects()`, call `nonceRepo.DeleteExpired(ctx)` once per scheduler tick (before or after the per-project loop — nonces are global, not per-project)
- Log the count of expired nonces deleted alongside the existing retention log lines

### 5. Fix cancel-path nonce leak

In `AIDataLiaisonPage.tsx`, when `callbackStatus === 'cancelled'`, call the backend callback endpoint with status `cancelled` instead of returning early. The backend already handles this correctly in `CompleteCallback()` — it calls `nonceStore.Validate()` (consuming the nonce) and then returns nil for cancelled status.

Change lines 133-136 from:
```typescript
if (callbackStatus === 'cancelled') {
  return;
}
```

To: remove the early return so cancelled callbacks flow through `processCallback()` the same as success callbacks. The backend `CompleteCallback` already handles `status == "cancelled"` by validating the nonce and doing nothing else.

## Files to Modify

- New migration: `migrations/0XX_nonces_table.up.sql` / `.down.sql`
- New: `pkg/repositories/nonce_repository.go`
- Modify: `pkg/services/nonce_store.go` — DB-backed implementation
- Modify: `pkg/services/installed_app.go` — pass context to nonce methods
- Modify: `ui/src/pages/AIDataLiaisonPage.tsx` — remove cancel early-return
- Modify: `pkg/services/retention_service.go` — inject `NonceRepository`, call `DeleteExpired()` in scheduler loop
- Modify: `pkg/server/server.go` (or wherever DI wiring happens) — inject repository into nonce store and retention service
