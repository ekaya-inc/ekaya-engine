package services

import (
	"github.com/google/uuid"

	"github.com/ekaya-inc/ekaya-engine/pkg/models"
)

// OntologyQuestionInput represents a question generated by the LLM during enrichment.
// This is the common format returned by entity, column, and relationship enrichment prompts.
type OntologyQuestionInput struct {
	Category string   `json:"category"` // terminology | enumeration | relationship | business_rules | temporal | data_quality
	Priority int      `json:"priority"` // 1=critical | 2=important | 3=nice-to-have
	Question string   `json:"question"` // Clear question for domain expert
	Context  string   `json:"context"`  // Relevant schema/data context
	Tables   []string `json:"tables,omitempty"`  // Affected table names
	Columns  []string `json:"columns,omitempty"` // Affected columns as "table.column"
}

// ConvertQuestionInputs converts LLM question inputs to OntologyQuestion models.
// The projectID and ontologyID are required; workflowID is optional (can be nil).
func ConvertQuestionInputs(
	inputs []OntologyQuestionInput,
	projectID uuid.UUID,
	ontologyID uuid.UUID,
	workflowID *uuid.UUID,
) []*models.OntologyQuestion {
	if len(inputs) == 0 {
		return nil
	}

	questions := make([]*models.OntologyQuestion, 0, len(inputs))
	for _, input := range inputs {
		// Skip invalid questions
		if input.Question == "" {
			continue
		}

		// Map priority: LLM uses 1=critical, 2=important, 3=nice-to-have
		// Model uses 1=highest, 5=lowest
		// Keep the same scale (1-3 maps to 1-3)
		priority := input.Priority
		if priority < 1 {
			priority = 3 // Default to nice-to-have
		}
		if priority > 5 {
			priority = 5
		}

		// Determine if required based on priority (critical questions are required)
		isRequired := priority == 1

		q := &models.OntologyQuestion{
			ProjectID:  projectID,
			OntologyID: ontologyID,
			WorkflowID: workflowID,
			Text:       input.Question,
			Priority:   priority,
			IsRequired: isRequired,
			Category:   input.Category,
			Reasoning:  input.Context, // Use context as reasoning
			Status:     models.QuestionStatusPending,
		}

		if len(input.Tables) > 0 || len(input.Columns) > 0 {
			q.Affects = &models.QuestionAffects{
				Tables:  input.Tables,
				Columns: input.Columns,
			}
		}

		questions = append(questions, q)
	}

	return questions
}
